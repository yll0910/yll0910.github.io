<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前端自动化测试分类 单元测试：针对“函数”，测试功能点的正确性 相关工具：Jest, Enzyme, @testing-library 系列   集成（e2e）测试：针对“流程”，测试关联模块间的特定流程的正确性 相关工具：Puppeteer, Selenium, WebdriverIO, CucumberJS   像素测试：针对“样式”，测试页面渲染效果的正确性 相关工具：Storybook,">
<meta property="og:type" content="article">
<meta property="og:title" content="tdd单元测试">
<meta property="og:url" content="http://example.com/2021/03/29/tdd%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="Yull&#39;s Blog">
<meta property="og:description" content="前端自动化测试分类 单元测试：针对“函数”，测试功能点的正确性 相关工具：Jest, Enzyme, @testing-library 系列   集成（e2e）测试：针对“流程”，测试关联模块间的特定流程的正确性 相关工具：Puppeteer, Selenium, WebdriverIO, CucumberJS   像素测试：针对“样式”，测试页面渲染效果的正确性 相关工具：Storybook,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yll0910.github.io/photoStore/others/image9.png">
<meta property="article:published_time" content="2021-03-29T09:00:33.000Z">
<meta property="article:modified_time" content="2021-03-29T09:07:47.851Z">
<meta property="article:author" content="Yu liuliu">
<meta property="article:tag" content="单元测试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yll0910.github.io/photoStore/others/image9.png">

<link rel="canonical" href="http://example.com/2021/03/29/tdd%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>tdd单元测试 | Yull's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yull's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">怕什么真理无穷，进一寸有一寸的欢喜</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">13</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/29/tdd%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Yu liuliu">
      <meta itemprop="description" content="美人如花隔云端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yull's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          tdd单元测试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-29 17:00:33 / 修改时间：17:07:47" itemprop="dateCreated datePublished" datetime="2021-03-29T17:00:33+08:00">2021-03-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前端自动化测试分类"><a href="#前端自动化测试分类" class="headerlink" title="前端自动化测试分类"></a>前端自动化测试分类</h1><ol>
<li>单元测试：针对“函数”，测试功能点的正确性<ul>
<li>相关工具：Jest, Enzyme, @testing-library 系列</li>
</ul>
</li>
<li>集成（e2e）测试：针对“流程”，测试关联模块间的特定流程的正确性<ul>
<li>相关工具：Puppeteer, Selenium, WebdriverIO, CucumberJS</li>
</ul>
</li>
<li>像素测试：针对“样式”，测试页面渲染效果的正确性<ul>
<li>相关工具：Storybook, Percy</li>
</ul>
</li>
</ol>
<h1 id="前端单元测试（UT）"><a href="#前端单元测试（UT）" class="headerlink" title="前端单元测试（UT）"></a>前端单元测试（UT）</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基本模式：每次针对单个函数（或组件）进行测试，通过预设的输入值（函数的参数，组件的 props），验证过程中发生的副作用及返回值是否符合预期。每个<code>describe</code>代表针对同一个目标的多个测试用例集合，每一个<code>it</code>或<code>test</code>代表一个用例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;increase&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 准备步骤，提供测试需要的参数</span></span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用参数执行目标函数</span></span><br><span class="line">  <span class="keyword">const</span> res = increase(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过断言判断目标是否正常运行</span></span><br><span class="line">  expect(res).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最简单的例子，针对<code>increase</code>函数，它具有入参<code>count</code>和返回值，我们上述用例中验证了<code>当传给函数的参数为1时，返回值为2</code>。</p>
<p>在更复杂的例子中，函数或组件会引用外部依赖，如<code>lodash</code>提供的方法或者其他文件由开发者自己定义的函数，这时候就需要通过 mock 的方式伪造一个<code>干净的环境</code>来避免脆弱的外部环境干扰你的测试过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useCallback&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;message&#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;umi/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnSubmit</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useCallback(<span class="keyword">async</span> (id) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> dispatch(&#123;</span><br><span class="line">      type: <span class="string">&#x27;model/effect&#x27;</span>,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        id</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">res.code === <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">      message.success(res.msg)</span><br><span class="line">      router.push(<span class="string">&#x27;/pathname&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [dispatch])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个比较复杂的例子，引入了 <code>antd </code>的<code>message</code>和 <code>umi </code>的<code>router</code>两个外部依赖，创建了一个返回函数的自定义 hook，并且在返回函数的执行过程中会根据<code>dispatch的返回值</code>进行不同的行为，以下是对应的测试用例写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderHook&#125; <span class="keyword">from</span> <span class="string">&#x27;@testing-library/react-hook&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将外部依赖进行mock，路径必须与实际引用的保持一致</span></span><br><span class="line">jest.mock(<span class="string">&#x27;antd&#x27;</span>)</span><br><span class="line">jest.mock(<span class="string">&#x27;umi/router&#x27;</span>)</span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;useOnSubmit&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 制造一个可被观测的函数作为后续参数，并让其下一次执行的结果为Promise.resolve(&#123;code: 0, msg: &#x27;success&#x27;&#125;)</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = jest.fn().mockResolvedValueOnce(&#123;<span class="attr">code</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;success&#x27;</span>&#125;)</span><br><span class="line">  <span class="keyword">const</span> id = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="comment">// 利用工具获得hook的返回值函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123;result&#125; = renderHook(<span class="function">() =&gt;</span> useOnSubmit(dispatch))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数</span></span><br><span class="line">  <span class="keyword">await</span> result.current(id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断言dispatch以特定参数被执行了</span></span><br><span class="line">  expect(dispatch).toBeCalledWith(&#123;</span><br><span class="line">    type: <span class="string">&#x27;model/effect&#x27;</span>,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      id: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 断言外部依赖被执行了</span></span><br><span class="line">  expect(message.success).toBeCalledWith(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  expect(router.push).toBeCalledWith(<span class="string">&#x27;/pathname&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="每个测试用例一个it函数代表"><a href="#每个测试用例一个it函数代表" class="headerlink" title="每个测试用例一个it函数代表"></a>每个测试用例一个it函数代表</h4><p>参数：</p>
<ul>
<li>字符串，代表测试用例名称：常用命名模式“被测对象在什么情况下是什么行为”</li>
<li>函数，实际测试用例过程</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it代表被测试对象，第一个参数描述它的预期行为</span></span><br><span class="line">it(<span class="symbol">&#x27;should</span> <span class="keyword">return</span> object when invoked&#x27;, () = &gt; &#123;</span><br><span class="line">  <span class="comment">// 增加断言语句</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h4><p>为了测试被测试对象在多种情况下的行为，需要创建多个单元测试用例，这里需要用测试套件（test suite）构建，用来组织多个it函数实例。<br> 测试套件可以嵌套使用：<strong>一个测试套件=测试用例+测试套件</strong><br> 测试套件和测试用例形成一个属性组织结构，<strong>执行顺序</strong>：<em>从上到下，从里到外</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&#39;actions&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  it(&#39;should return object when invoked&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 可以有更多it函数调用</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>多个it放到一个describe中主要目的是为了重置共同环境设置。<br> describe中包含如下函数帮助重用代码：</p>
<ul>
<li><code>beforeAll </code>在开始测试套件之前执行一次</li>
<li><code>afterAll</code> 在结束测试套件中所有测试用例之后执行一次</li>
<li><code>beforeEach </code>每个测试用例在执行之前都执行一次</li>
<li><code>afterEach</code> 每个测试用例在执行之后都执行一次</li>
</ul>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 相对好测试一点，因为promise 可以使用then的链式调用。只要等待它的resolve, 然后调用then 来接受返回的数据进行对比就可以了，如果没有resolve 肯定是失败了。等待resolve，在测试中是使用的return, return Promise 的调用，就是等待它的resolve. 把<code>fetchData</code> 函数转化成使用promise 进行请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    request(<span class="string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = fetchData;</span><br></pre></td></tr></table></figure>

<p>测试函数<code>(func.test.js)</code></p>
<p>改为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;should return data when fetchData request success&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        expect(<span class="built_in">JSON</span>.parse(data)).toEqual(&#123;</span><br><span class="line">            <span class="string">&quot;userId&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: <span class="string">&quot;delectus aut autem&quot;</span>,</span><br><span class="line">            <span class="string">&quot;completed&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>　进行promise测试的时候，在测试代码中，一定要注意使用return, 如果没有return，就没有等待，没有等待，就没有resolve，then 也就不会执行了，测试效果达不到。</p>
<h4 id="Mock函数"><a href="#Mock函数" class="headerlink" title="Mock函数"></a>Mock函数</h4><p>Mock函数就是把依赖换成我们可控的内容，实现测试项和它的依赖项隔离。</p>
<p>jest创建一个mock函数最简单的方法是调用<code>jest.fn()</code>方法</p>
<p>mock函数还有mock属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forEach = <span class="function">(<span class="params">array, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> element = array[index];</span><br><span class="line">        callback(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;should call callback when forEach&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mockFun = jest.fn(); <span class="comment">// mock 函数</span></span><br><span class="line">    <span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    forEach(array, mockFun); <span class="comment">// 用mock函数代替真实的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(mockFun.mock);</span><br><span class="line">    expect(mockFun.mock.calls.length).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>calls保存的是调用状态，results保存的是返回值。</p>
<p>calls 是一个数组，每一次的调用都组成数组的一个元素，在这里调用了两次，就有两个元素。每一个元素又是一个数组，它则表示的是函数调用时的参数，因为每次的调用都传递了一个参数给函数，所以数组只有一项。如果有多个参数，数组就有多项，按照函数中的参数列表依次排列。<code>expect(mockFun.mock.call[0][0].toBe(1))</code>就是断言第一次调用的时候传递的参数是不是1</p>
<h4 id="设置函数返回值"><a href="#设置函数返回值" class="headerlink" title="设置函数返回值"></a>设置函数返回值</h4><p>函数返回值。有的时候，你不想调用函数，直接获取到函数的返回值就可以了，比如异步函数, 以<code>fetchData</code> 为例，它直接返回一个promise 就好了，根本没有必要请求服务器。mock函数有<code>mockReturnValue()</code>, 它的参数就是返回值。不过它不能返回promise. 可以使用<code>mockResolvedValue</code>直接返回promise的值. 对<code>fetchData</code> 进行mock， 然后设置它的<code>mockResolvedValue()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fetchData = <span class="built_in">require</span>(<span class="string">&#x27;./func&#x27;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;should return data when fetchData request success&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetchData = jest.fn();</span><br><span class="line">    fetchData.mockResolvedValue(&#123;<span class="attr">name</span>: <span class="string">&#x27;sam&#x27;</span>&#125;)</span><br><span class="line">   <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">       expect(res).toEqual(&#123;<span class="attr">name</span>: <span class="string">&#x27;sam&#x27;</span>&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><p>但是当我们使用<code>jest.mock()</code> 来mock一个模块的时候，jest 已经把所有的方法自动mock成jest.fn()，无法给它传参，也就无法提供实现了。这就要用到第二种mock实现方法了，mock 函数提供了一个方法<code>mockImplementation()</code>, 它的参数也是一个函数实现，使用<code>mockImplementation() </code>来mock <code>fetchData</code>，让它返回<code>&#123;name: &#39;sam&#39;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">&#x27;./func.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> fetchData = <span class="built_in">require</span>(<span class="string">&#x27;./func&#x27;</span>).fetchData;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;should return data when fetchData request success&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   fetchData.mockImplementation(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;<span class="attr">name</span>: <span class="string">&#x27;sam&#x27;</span>&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">       expect(res).toEqual(&#123;<span class="attr">name</span>: <span class="string">&#x27;sam&#x27;</span>&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>　　还有一种mock实现的方式，<code>jest.spyOn()</code>, 它接受两个参数，一个是对象，一个是对象上的某一个方法，返回一个mock函数，使用<code>jest.spyOn()</code> mock add方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./func&#x27;</span>)</span><br><span class="line">　<span class="keyword">const</span> addMock = jest.spyOn(math, <span class="string">&quot;add&quot;</span>); <span class="comment">// mock math 对象上的add方法</span></span><br><span class="line">　addMock.mockImplementation(<span class="function">() =&gt;</span> <span class="string">&quot;mock&quot;</span>); <span class="comment">// 提供一个实现</span></span><br></pre></td></tr></table></figure>

<p>　使用<code>spyOn</code> 进行mock的好处是在同一个test 下，它可以restore, 恢复到以前默认mock的状态。这样就不用写<code>beforeEach</code> 和<code>aftereEach</code> 函数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./func&#x27;</span>);test(<span class="string">&quot;calls math.add&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> addMock = jest.spyOn(math, <span class="string">&quot;add&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// override the implementation</span></span><br><span class="line">  addMock.mockImplementation(<span class="function">() =&gt;</span> <span class="string">&quot;mock&quot;</span>);</span><br><span class="line">  expect(addMock(<span class="number">1</span>, <span class="number">2</span>)).toEqual(<span class="string">&quot;mock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// restore the original implementation</span></span><br><span class="line">  addMock.mockRestore();</span><br><span class="line">  expect(addMock(<span class="number">1</span>, <span class="number">2</span>)).toBeUndefined();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然，<code>spyOn</code> 还有另外一个功能，就是监听函数，有时我们并不想mock 函数，改变函数的实现，只想监听一下它有没有被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./func&#x27;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;should call add&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callMath</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> math.add(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> addMock = jest.spyOn(math, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line">    callMath(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    expect(addMock).toBeCalled();  <span class="comment">// toBeCalled, 就是函数有没有被调用。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<img src="https://yll0910.github.io/photoStore/others/image9.png" />

<h2 id="关于依赖项"><a href="#关于依赖项" class="headerlink" title="关于依赖项"></a>关于依赖项</h2><p>这是一个比较复杂的例子，引入了 antd 的<code>message</code>和 umi 的<code>router</code>两个外部依赖，创建了一个返回函数的自定义 hook，并且在返回函数的执行过程中会根据<code>dispatch的返回值</code>进行不同的行为，以下是对应的测试用例写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderHook&#125; <span class="keyword">from</span> <span class="string">&#x27;@testing-library/react-hook&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将外部依赖进行mock，路径必须与实际引用的保持一致</span></span><br><span class="line">jest.mock(<span class="string">&#x27;antd&#x27;</span>)</span><br><span class="line">jest.mock(<span class="string">&#x27;umi/router&#x27;</span>)</span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;useOnSubmit&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 制造一个可被观测的函数作为后续参数，并让其下一次执行的结果为Promise.resolve(&#123;code: 0, msg: &#x27;success&#x27;&#125;)</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = jest.fn().mockResolvedValueOnce(&#123;<span class="attr">code</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;success&#x27;</span>&#125;)</span><br><span class="line">  <span class="keyword">const</span> id = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="comment">// 利用工具获得hook的返回值函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123;result&#125; = renderHook(<span class="function">() =&gt;</span> useOnSubmit(dispatch))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数</span></span><br><span class="line">  <span class="keyword">await</span> result.current(id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断言dispatch以特定参数被执行了</span></span><br><span class="line">  expect(dispatch).toBeCalledWith(&#123;</span><br><span class="line">    type: <span class="string">&#x27;model/effect&#x27;</span>,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      id: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 断言外部依赖被执行了</span></span><br><span class="line">  expect(message.success).toBeCalledWith(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  expect(router.push).toBeCalledWith(<span class="string">&#x27;/pathname&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="关于分支"><a href="#关于分支" class="headerlink" title="关于分支"></a>关于分支</h2><p>当目标函数存在多个分支时，每个分支应该都设置一个单独的 case 进行测试，多个串行或嵌套的分支应该以<code>乘法</code>来统计总 case 数，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;请输入数字&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>(value) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;租用天数不小于1天&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;请输入正整数&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>(value) &gt; <span class="number">3650</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;租用天数不大于3650天&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述例子，应该设置总计 5 个 case，分别验证入参<code>不是数值</code>,<code>过小</code>,<code>非整数</code>,<code>过大</code>及<code>正确</code>时的返回值是否符合预期</p>
<h2 id="关于依赖的-mock"><a href="#关于依赖的-mock" class="headerlink" title="关于依赖的 mock"></a>关于依赖的 mock</h2><p>一般对于被测试函数及文件有 3 类依赖：<code>参数</code>形式的外部依赖、对于<code>全局对象</code>（如 window）及其属性的依赖 和 <code>引入</code>形式的跨文件依赖。</p>
<ul>
<li>针对第一种依赖，一般使用临时构造一个 mock 对象或者 mock 函数，在进行函数调用时传入来解决。</li>
<li>针对第二和第三种依赖，通常采用<code>jest.spyOn</code>和<code>jest.mock</code>方法进行模拟。两者的差异是：<code>jest.mock</code>是完全<code>替换</code>掉被模拟的目标，在函数调用时只会调用 jest 提供的 mock 函数；而<code>jest.spyOn</code>是在原函数上进行一层<code>包装</code>，实际执行过程中也会执行原函数。<ul>
<li>当你不关注目标的细节时，建议使用<code>jest.mock</code>进行模拟，否则应使用<code>jest.spyOn</code>。比如当你的依赖项是一个发送请求的 fetch 方法时，通常采用<code>jest.mock</code>，避免调用实际的请求 api；当你的依赖项是 window 对象的某个属性时，通常使用<code>jest.spyOn</code>，因为 window 对象的其他属性可能也是你关注的目标</li>
<li>由于<code>jest.mock</code>用于模拟<code>整个模块</code>块时，必须处于文件顶层，它的影响范围是整个文件。对于被模拟目标进行进一步模拟（返回值等）时，需要根据测试文件中各 case 的要求选择恰当的方式。如果所有 case 对被模拟目标有通用的要求（比如返回值相同），则可以利用<code>jest.mock</code>的第二个参数<code>factory</code>直接指明依赖的行为；否则应在各 case 内单独 mock 其行为</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入依赖</span></span><br><span class="line"><span class="keyword">import</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">&#x27;./test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//依赖并调用其他文件下的方法</span></span><br><span class="line">  <span class="keyword">if</span> (test()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对依赖进行mock</span></span><br><span class="line">jest.mock(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假如test会根据window中的某个属性值返回不同的结果（true/false）</span></span><br><span class="line"><span class="comment"> * 由于我们并不关注test如果通过window进行判断，只关注其返回值是true还是false</span></span><br><span class="line"><span class="comment"> * 因此采用jest.mock进行模拟，并在各个case下单独模拟其返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;case 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//经过jest.mock的模块，各函数均已变成mock函数</span></span><br><span class="line">  <span class="keyword">const</span> testMock = test <span class="keyword">as</span> jest.Mock</span><br><span class="line">  <span class="comment">//case内模拟test方法的返回值为true</span></span><br><span class="line">  testMock.mockReturnValueOnce(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  expect(foo()).toBe(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;case 2&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//经过jest.mock的模块，各函数均已变成mock函数</span></span><br><span class="line">  <span class="keyword">const</span> testMock = test <span class="keyword">as</span> jest.Mock</span><br><span class="line">  <span class="comment">//case内模拟test方法的返回值为false</span></span><br><span class="line">  testMock.mockReturnValueOnce(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  expect(foo()).toBe(-<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引入依赖</span><br><span class="line">import &#123; test &#125; from &#39;.&#x2F;test&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;被测试函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">  &#x2F;&#x2F;依赖并调用其他文件下的方法</span><br><span class="line">  if (test()) &#123;</span><br><span class="line">    return 1</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对依赖进行mock</span><br><span class="line">jest.mock(&#39;.&#x2F;test&#39;, () &#x3D;&gt; (&#123;</span><br><span class="line">  test: jest.fn().mockReturnValueOnce(true)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 由于当前文件下只有一个case（或者多个case有同样的要求）</span><br><span class="line"> * 因此采用jest.mock进行模拟，并提供factory参数全局模拟其行为</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">it(&#39;case 1&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  expect(foo()).toBe(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
      
       <div>
            
            <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
            
        </div>
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="tag"># 单元测试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/06/%E5%BE%AE%E5%89%8D%E7%AB%AF-qiankun/" rel="prev" title="微前端-qiankun">
      <i class="fa fa-chevron-left"></i> 微前端-qiankun
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">前端自动化测试分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88UT%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">前端单元测试（UT）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%B8%80%E4%B8%AAit%E5%87%BD%E6%95%B0%E4%BB%A3%E8%A1%A8"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">每个测试用例一个it函数代表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#describe"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">describe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mock%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.0.4.</span> <span class="nav-text">Mock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.1.0.5.</span> <span class="nav-text">设置函数返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82"><span class="nav-number">2.1.0.5.1.</span> <span class="nav-text">传参</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">2.2.</span> <span class="nav-text">关于依赖项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%88%86%E6%94%AF"><span class="nav-number">2.3.</span> <span class="nav-text">关于分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%BE%9D%E8%B5%96%E7%9A%84-mock"><span class="nav-number">2.4.</span> <span class="nav-text">关于依赖的 mock</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yu liuliu"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Yu liuliu</p>
  <div class="site-description" itemprop="description">美人如花隔云端</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yu liuliu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
</html>
